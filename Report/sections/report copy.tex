\section{Part A: Address Decoder Design}

\subsection{Objective}
The objective of this lab is to design a custom address decoder in Verilog for a given memory system. The decoder is responsible for selecting one of the four ROM chips in a memory-mapped system with active-low chip select lines. This project involves verifying the functionality of the address decoder by testing it with a provided testbench.

\subsection{Project Description}
The address decoder module is designed to interface with a 4-chip memory system where each ROM chip stores 64 words. The memory-mapped address space is divided into four contiguous regions, each assigned to one ROM. The decoder ensures that only one ROM chip is selected at any given time, based on the incoming address and control signals.

The ROM chips are configured with the following address ranges:
\begin{itemize}
    \item \textbf{ROM00:} \$400 - \$43F (Values 0 - 63)
    \item \textbf{ROM01:} \$440 - \$47F (Values 64 - 127)
    \item \textbf{ROM10:} \$480 - \$4BF (Values 128 - 191)
    \item \textbf{ROM11:} \$4C0 - \$4FF (Values 192 - 255)
\end{itemize}

The decoder uses active-low signals for chip selection, ensuring compatibility with the memory system design. The address decoding logic is implemented to satisfy the given ranges and the UDS/LDS byte-selection signals.

\subsection{Implementation}

\subsubsection{Memory System: memory\_system.v}
The \texttt{memory\_system.v} module implements the address decoder logic to interface with four ROM chips. The module is divided into three main components:
\begin{itemize}
    \item Address Decoding Logic: Determines which ROM chip is selected based on the input address and control signals.
    \item Internal Address Mapping: Extracts the internal ROM address from the input address.
    \item Data Output Multiplexing: Ensures only the selected ROM outputs data to the shared data bus.
\end{itemize}

\subsubsection{Address Decoding Logic}
The address decoding logic uses the 12-bit input address and the UDS/LDS control signals to generate the active-low chip select signals (\texttt{ROM\_SEL}). Each ROM is assigned a unique address range, and only one \texttt{ROM\_SEL} signal is active (low) at any time.

\begin{lstlisting}[language=Verilog, caption={Address Decoding Logic}]
assign ROM00_SEL = ~((Address >= 12'h400) && (Address < 12'h440) && ~UDS);
assign ROM01_SEL = ~((Address >= 12'h440) && (Address < 12'h480) && ~LDS);
assign ROM10_SEL = ~((Address >= 12'h480) && (Address < 12'h4C0) && ~UDS);
assign ROM11_SEL = ~((Address >= 12'h4C0) && (Address < 12'h500) && ~LDS);
\end{lstlisting}

Each \texttt{ROM\_SEL} signal is active (0) when the input address falls within the ROM's range and the corresponding control signal (\texttt{UDS} or \texttt{LDS}) is asserted. For instance, \texttt{ROM00\_SEL} is active for addresses in the range \$400 - \$43F when \texttt{UDS = 0}. Similarly, \texttt{ROM01\_SEL} is active for addresses in the range \$440 - \$47F when \texttt{LDS = 0}.

\subsubsection{Internal Address Mapping}
The internal address mapping extracts the lower bits of the 12-bit address to form a 6-bit address for accessing the ROM contents. The least significant bit (\texttt{A[0]}) is ignored since byte selection is handled by \texttt{UDS} and \texttt{LDS}.

\begin{lstlisting}[language=Verilog, caption={Internal Address Mapping}]
wire [5:0] rom_address = Address[6:1];
\end{lstlisting}

The 6-bit \texttt{rom\_address} corresponds to the memory location within each ROM chip. For example, an address of \$41A (\texttt{0100 0001 1010}) maps to \texttt{rom\_address = 011010 (decimal 26)}.

\subsubsection{ROM Module Instantiation}
The address decoder instantiates four ROM modules, each corresponding to a unique address range. The \texttt{ROM\_SEL} signals enable or disable each ROM module, while the 6-bit \texttt{rom\_address} selects the specific memory location within the active ROM.

\begin{lstlisting}[language=Verilog, caption={ROM Module Instantiation}]
ROM0_1 ROM00 (.mem_address(rom_address), .CS(ROM00_SEL), .data_1(ROM00_Data));
ROM0_2 ROM01 (.mem_address(rom_address), .CS(ROM01_SEL), .data_1(ROM01_Data));
ROM1_1 ROM10 (.mem_address(rom_address), .CS(ROM10_SEL), .data_1(ROM10_Data));
ROM1_2 ROM11 (.mem_address(rom_address), .CS(ROM11_SEL), .data_1(ROM11_Data));
\end{lstlisting}

Each ROM module corresponds to one of the defined address ranges:
\begin{itemize}
    \item \texttt{ROM00}: \$400 - \$43F
    \item \texttt{ROM01}: \$440 - \$47F
    \item \texttt{ROM10}: \$480 - \$4BF
    \item \texttt{ROM11}: \$4C0 - \$4FF
\end{itemize}
The \texttt{CS} (chip select) input ensures that only one ROM module is active at a time, and the data output (\texttt{ROM\_Data}) is forwarded to the data bus.

\subsubsection{Data Output Multiplexing}
The output data from the active ROM module is multiplexed onto the shared data bus. Only one ROM's data is selected based on the active \texttt{ROM\_SEL} signal.

\begin{lstlisting}[language=Verilog, caption={Data Output Multiplexing}]
assign Data = (ROM00_SEL == 0 ? ROM00_Data :
              ROM01_SEL == 0 ? ROM01_Data :
              ROM10_SEL == 0 ? ROM10_Data :
              ROM11_SEL == 0 ? ROM11_Data : 8'bz);
\end{lstlisting}

The \texttt{Data} bus reflects the output of the active ROM module. If no ROM is selected (e.g., address outside the valid range), the data bus is tri-stated (\texttt{8'bz}). For example, for address \$41A, \texttt{ROM00\_SEL = 0} and \texttt{ROM00\_Data} is forwarded to \texttt{Data}.

\subsection{Demo}
The address decoder was demonstrated to the instructor using the provided testbench. The decoder successfully selected the correct ROM chip and fetched the expected data values for each test case.

\subsection{Results}
The simulation results validate the functionality of the address decoder. The waveform in Figure \ref{fig:simulation} shows that the \texttt{ROM\_SEL} signals correctly activate for each address range, and the expected data is outputted for the given addresses.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/simulation.png}
    \caption{Simulation results of the address decoder for the provided testbench.}
    \label{fig:simulation}
\end{figure}

\subsection{Conclusion}
This lab successfully implemented an address decoder for a memory-mapped system with active-low chip select lines. The decoder was verified through simulation and demonstrated to the instructor. The design correctly selects the appropriate ROM chip and outputs the expected data values.

\newpage
\section{Part B: MicroBlaze Processor}

\subsection{Objective}
The objective of this part of the lab is to interface UART with the MicroBlaze soft-core processor using Vivado and Vitis Design Suite. The task involves replacing the tutorial's \texttt{helloworld.c} program with a custom C code that computes and outputs the first five terms of the Fibonacci sequence. The program is executed on the FPGA, and the output is displayed on the Vitis Serial Terminal.

\subsection{Implementation}

\subsubsection{Vivado Design}
In Vivado, the hardware platform is designed by adding and configuring the MicroBlaze soft-core processor and its peripherals. The steps followed are:
\begin{enumerate}
    \item Create a new block design and add the MicroBlaze processor.
    \item Configure the MicroBlaze processor with:
    \begin{itemize}
        \item A 64 KB Block RAM memory for program and data storage.
        \item UART module for serial communication.
    \end{itemize}
    \item Modify the clock and reset path and logic.
    \item Validate the design and generate the bitstream.
    \item Export the hardware design for use in Vitis.
\end{enumerate}

\subsubsection{Vitis Software Development}
Using the exported hardware design from Vivado, a new application project is created in Vitis. The original \texttt{helloworld.c} program from the tutorial is replaced with the Fibonacci sequence program. The source code for the custom program is provided below:

\begin{lstlisting}[language=C, caption={Fibonacci Sequence Program}]
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

int main()
{
    init_platform();

    xil_printf("Fibonacci Sequence:\n\r");

    int n1 = 0, n2 = 1, n3, i;
    int terms = 5; // Number of terms to print

    xil_printf("%d\n\r", n1);
    xil_printf("%d\n\r", n2);

    for (i = 2; i < terms; i++) {
        n3 = n1 + n2;
        xil_printf("%d\n\r", n3);
        n1 = n2;
        n2 = n3;
    }

    cleanup_platform();
    return 0;
}
\end{lstlisting}

After coding, the application is compiled and loaded onto the FPGA. The program output is observed on the Vitis Serial Terminal.

\subsubsection{Answers to Questions}
\begin{enumerate}
    \item \textbf{What is the MicroBlaze and what are its characteristic features?}
    MicroBlaze is a processor built into Xilinx FPGAs. Think of it as a small, customizable CPU that fits into FPGA designs. Some of its features include:
    \begin{itemize}
        \item A flexible architecture where you can add cache, memory, or peripherals depending on your needs.
        \item Compatibility with AXI interfaces, making it easy to connect to other components.
        \item A lightweight design, perfect for projects with limited resources.
        \item Full support in Xilinx tools like Vivado and Vitis for streamlined setup and programming.
    \end{itemize}
    
    \item \textbf{What are the key features and benefits of the AXI\_UartLite module added to the Block Design?}
    The AXI\_UartLite module handles serial communication for the MicroBlaze processor. Its main benefits are:
    \begin{itemize}
        \item Full-duplex communication, allowing data to be sent and received simultaneously.
        \item A simple setup process with minimal resource usage, suitable for basic designs.
        \item Seamless integration with the MicroBlaze through the AXI interface.
        \item Useful for debugging, as it enables communication with the Vitis Serial Terminal.
    \end{itemize}
    
    \item \textbf{What is the utility of having the AXI\_Interconnect module?}
    The AXI\_Interconnect connects the MicroBlaze processor to its peripherals. Itâ€™s essential because:
    \begin{itemize}
        \item It ensures smooth communication by routing data and decoding addresses.
        \item Multiple devices can connect at once, allowing for more complex designs.
        \item It simplifies the design process by handling data transfers and address decoding automatically.
    \end{itemize}
\end{enumerate}


\subsection{Demo}
The Fibonacci sequence program was prepared for demonstration to the instructor using the Vitis Serial Terminal. Due to technical difficulties during the attempt, the project could not be uploaded to the FPGA for execution. However, all prior steps, including creating the design in Vivado, writing the C code in Vitis, and building the project, were completed successfully. The instructor was satisfied with the attached project files for Part B.

\subsection{Results}
While the final upload and execution on the FPGA could not be completed due to technical issues, the Fibonacci sequence program was verified through simulation and the preparation process. All other steps were followed and successfully completed. The attached project demonstrates the implementation of the Fibonacci sequence program.

\subsection{Conclusion}
This lab provided valuable experience in working with the MicroBlaze processor and AXI peripherals in Vivado and Vitis. Key takeaways include understanding how to integrate the AXI\_UartLite module for UART communication and using the AXI\_Interconnect for data routing. Although technical difficulties prevented the final execution on the FPGA, the process of creating and verifying the project helped reinforce important concepts about FPGA design workflows and debugging. The attached project serves as a complete demonstration of the intended functionality.
